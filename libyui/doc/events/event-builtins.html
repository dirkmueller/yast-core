<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
    <title>Event Handling in the YaST2 User Interfaces</title>
</head>

<style type="text/css">
#code {
    background-color:#E0E0E0;
    font-weight:normal;
}
#code-highlight {
    background-color:#B0B0F0;
    font-weight:bolder;
}
#code-keyword {
    background-color:#E0E0E0;
    font-weight:bold;
}
</style>


<body bgcolor=#F0F0F8>


<table width=100%>
    <tr bgcolor=#B0B0F0><td>
	<h1 align=center>Event Handling in the YaST2 UI</h1>
    </td></tr>
    <tr><td>
	<p align=center>Author: Stefan Hundhammer 
	    &lt;<a href="mailto:sh@suse.de?subject=YaST2 Event Handling">sh@suse.de</a>&gt;
	</p></td></tr>
</table>




<h1><a name="contents">Contents</a></h1>



<h1><a name="ui_builtins">Event-related UI Builtin Functions</a></h1>

<p><i>
<b>Note:</b> This section describes only those builtin functions of the YaST2
user interface that are relevant for event handling. The YaST2 UI has many more
builtin functions that are not mentioned here. 
Refer to the <a href="YCP-builtins-ui.html">UI builtin reference</a> for
details.
</i></p>


<h2><a name="UserInput">UserInput()</a></h2>

<p>
UI::UserInput() waits for the user to do some input. Normally this means it
waits until the user clicks on a push button. 
<p>
Widgets that have the <a href="notify">notify option</a> set can also cause
UserInput() to return - i.e. to resume the control flow in the YCP code with
the next statement after UserInput().
<p>
As long as the user does not do any such action, UserInput() waits,
i.e. execution of the YCP code stops in UserInput().
In particular, entering text in input fields (TextEntry widgets) or selecting
an entry in a list (SelectionBox widget) does not make UserInput() continue
unless the respective widget has the <a href="notify">notify option</a> set.
<p>
UserInput() returns the ID of the widget that caused it to return. This is
usually a button ID. It does <b>not</b> return any text entered etc.; use
UI::QueryWidget() to retrieve the contents of the dialog's widgets.
<p>
Such a widget ID can be of any valid YCP type, but using simple types like
<i>symbol</i>, <i>string</i> or maybe <i>integer</i> is strongly recommended. 
<p>
Although it is technically still possible, using complex data types like
<i>map</i>, <i>list</i> or even <i>term</i> (which might even contain YCP code
to be executed with <i>eval()</i>) is discouraged. Support for this may be
dropped without notice in future versions.
<p>
Since it depends on exactly what types the YCP application developer choses for
his widgets, UserInput()'s return type is <i>any</i>. You may safely use a
variable of the actual type you are using (usually <i>symbol</i> or
<i>string</i>). 

<h3>Usage:</h3>
<blockquote><pre id="code">
any widget_id = <span id="code-keyword">UI::UserInput()</span>;

</pre></blockquote>


<h3>Example:</h3>

<blockquote><pre id="code">
// UserInput.ycp
//
// Example for common usage of UI::UserInput()

{
    // Build dialog with two input fields and three buttons.
    //
    // Output goes to the log file: ~/.y2log for normal users
    // or /var/log/YaST2/y2log for root.
    
    string name = "Tux";
    string addr = "Antarctica";
    
    <span id="code-keyword">UI::OpenDialog</span>(
		   `VBox(
			 `TextEntry(`id(`name), "&Name:",    name ),
			 `TextEntry(`id(`addr), "&Address:", addr ),
			 `HBox(
			       `PushButton(`id(`ok     ), "&OK" ),
			       `PushButton(`id(`cancel ), "&Cancel" ),
			       `PushButton(`id(`help   ), "&Help"   )
			       )
			 )
		   );

    <b>symbol</b> widget_id = nil; // All widget IDs used here are symbols

    // Event loop
    
    repeat
    {
	widget_id = <span id="code-highlight">UI::UserInput()</span>;

	if ( widget_id == `ok )
	{
	    // process "OK" button
	    
	    y2debug( "OK button activated" );

	    
	    // Retrieve widget contents
	    
	    name = <span id="code-keyword">UI::QueryWidget</span>(`id(`name ), `Value );
	    addr = <span id="code-keyword">UI::QueryWidget</span>(`id(`addr ), `Value );
	}
	else if ( widget_id == `cancel )
	{
	    // process "Cancel" buttton
	    // or window manager close button (this also returns `cancel)
	    
	    y2debug( "Cancel button activated" );
	}
	else if ( widget_id == `help )
	{
	    // process "Help" button
	    
	    y2debug( "Help button activated" );
	}

	// No other "else" branch necessary: None of the TextEntry widget has
	// the `notify option set, so none of them can make UserInput() return.
	
    } until ( widget_id == `ok || widget_id == `cancel );


	
    // Close the dialog - but only after retrieving all information that may
    // still be stored only in its widgets: QueryWidget() works only for
    // widgets that are still on the screen!
	
    <span id="code-keyword">UI::CloseDialog()</span>;

    
    // Dump the values entered into the log file
    
    y2debug( "Name: %1 Address: %2", name, addr );
}

</pre></blockquote>




<h2><a name="PollInput">PollInput()</a></h2>

<p>
PollInput() is very much like <a href="#UserInput">UserInput()</a>, but it
doesn't wait. It only checks if there is a user event pending - the user may
have clicked on a button since the last call to PollInput() or 
<a href="#UserInput">UserInput()</a>. 
<p>
If there is one, the ID of the widget (usually a button unless other widgets
have the  <a href="notify">notify option</a> set) ID is returned. If there is
none, <i>nil</i> (the YCP value for "nothing", "invalid") is returned.
<p>
Use PollInput() to check if the user wishes to abort operations of long
duration that are performed in a loop. Notice that PollInput() will result in a
"busy wait", so don't simply use it everywhere instead of 
<a href="#UserInput">UserInput()</a>.
<p>
Notice there is also <a href="#TimeoutUserInput">TimeoutUserInput()</a> 
and <a href="#WaitForEvent">WaitForEvent()</a>
that both accept a millisecond timeout argument.

<h3>Usage:</h3>
<blockquote><pre id="code">
any widget_id = <span id="code-keyword">UI::PollInput()</span>;

</pre></blockquote>

<h3>Example:</h3>

<blockquote><pre id="code">
// PollInput.ycp
//
// Example for common usage of UI::PollInput()

{
    // Build dialog with two labels and a "stop" button.

    integer count     = 0;
    integer count_max = 10000;

    <span id="code-keyword">UI::OpenDialog</span>(
		   `VBox(
			 `Label( "Calculating..." ),
			 `Label(`id(`count ), sformat( "%1 of %2", count, count_max ) ),
			 `PushButton(`id(`stop), "&Stop" )
			 )
		   );

    any widget_id = nil;

    // Event loop

    repeat
    {
	widget_id = <span id="code-highlight">UI::PollInput()</span>;


	// Simulate heavy calculation

	sleep(200); // milliseconds

	// Update screen to show that the program is really busy
	count = count + 1;
	<span id="code-keyword">UI::ChangeWidget</span>(`id(`count), `Value, sformat( "%1 of %2", count, count_max ) );
	<span id="code-keyword">UI::RecalcLayout()</span>; // Might be necessary when the label becomes wider

    } until ( widget_id == `stop || count >= count_max );

    <span id="code-keyword">UI::CloseDialog()</span>;
}

</pre></blockquote>



<h2><a name="TimeoutUserInput">TimeoutUserInput()</a></h2>
<h2><a name="WaitForEvent">WaitForEvent()</a></h2>


<h1><a name="event_reference">Event Reference</a></h1>


</body>

</html>


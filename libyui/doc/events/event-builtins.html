<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
    <title>Event Handling in the YaST2 User Interfaces</title>
    <link rel="stylesheet" type="text/css" href="events.css">
</head>

<body>


<h1 class="doc-title">Event Handling in the YaST2 UI</h1>

<p align=center>
Author: Stefan Hundhammer
&lt;<a href="mailto:sh@suse.de?subject=YaST2 Event Handling">sh@suse.de</a>&gt;
</p>

<h1 align=center><a name="ui_builtins">Event-related UI Builtin Functions</a></h1>

<table class="navigation-bar" width=100%>
    <tr>
	<td width="33%" align="left">Prev: (none)</td>
	<td width="33%" align="center">Top: <a href="index.html">Event Handling Index</a></td>
	<td width="33%" align="right">Next: <a href="event-reference.html">Event Reference</a></td>
</table>




<h2><a name="quick_reference">Quick Reference</a></h2>

<table border="1">
    <tr>
	<td><a href="#UserInput">UserInput()</a></td>
	<td>Waits for user input and returns a widget ID.</td>
    </tr>
    <tr>
	<td><a href="#PollInput">PollInput()</a></td>
	<td>
	    Checks for pending user input. Does not wait. Returns a widget ID
	    or <i>nil</i> if no input is available.
	</td>
    </tr>
    <tr>
	<td><a href="#TimeoutUserInput">TimeoutUserInput</a> (&nbsp;int&nbsp;timeout&nbsp;)</td>
	<td>
	    Waits for user input and returns a widget ID.
	    Returns ID <i>`timeout</i> if no input is available for
	    <i>timeout</i> milliseconds.
	</td>
    </tr>
    <tr>
	<td>
	    <a href="#WaitForEvent">WaitForEvent()</a><br>
	    <a href="#WaitForEvent">WaitForEvent</a> (&nbsp;int&nbsp;timeout&nbsp;)
	</td>
	<td>
	    Waits for user input and returns an event map.
	    Returns ID <i>`timeout</i> if no input is available for
	    <i>timeout</i> milliseconds.
	</td>
    </tr>
</table>


<p><i>
<b>Note:</b> This section describes only those builtin functions of the YaST2
user interface that are relevant for event handling. The YaST2 UI has many more
builtin functions that are not mentioned here.
Refer to the <a href="../YCP-builtins-ui.html">UI builtin reference</a> for
details.
</i></p>


<h2><a name="UserInput">UserInput()</a></h2>

<p>
UI::UserInput() waits for the user to do some input. Normally this means it
waits until the user clicks on a push button.
<p>
Widgets that have the <a href="events-general.html#notify">notify option</a>
set can also cause UserInput() to return - i.e. to resume the control flow in
the YCP code with the next statement after UserInput().
<p>
As long as the user does not do any such action, UserInput() waits,
i.e. execution of the YCP code stops in UserInput().
In particular, entering text in input fields (TextEntry widgets) or selecting
an entry in a list (SelectionBox widget) does not make UserInput() continue
unless the respective widget has the <a href="general#notify">notify option</a> set.
<p>
UserInput() returns the ID of the widget that caused it to return. This is
usually a button ID. It does <b>not</b> return any text entered etc.; use
UI::QueryWidget() to retrieve the contents of the dialog's widgets.
<p>
Such a widget ID can be of any valid YCP type, but using simple types like
<i>symbol</i>, <i>string</i> or maybe <i>integer</i> is strongly recommended.
<p>
Although it is technically still possible, using complex data types like
<i>map</i>, <i>list</i> or even <i>term</i> (which might even contain YCP code
to be executed with <i>eval()</i>) is discouraged. Support for this may be
dropped without notice in future versions.
<p>
Since it depends on exactly what types the YCP application developer choses for
his widgets, UserInput()'s return type is <i>any</i>. You may safely use a
variable of the actual type you are using (usually <i>symbol</i> or
<i>string</i>).

<h3>Usage:</h3>
<pre class="code">
any widget_id = <b>UI::UserInput()</b>;

</pre>


<h3>Example:</h3>

<pre class="code">
// UserInput.ycp
//
// Example for common usage of UI::UserInput()

{
    // Build dialog with two input fields and three buttons.
    //
    // Output goes to the log file: ~/.y2log for normal users
    // or /var/log/YaST2/y2log for root.

    string name = "Tux";
    string addr = "Antarctica";

    <b>UI::OpenDialog</b>(
		   `VBox(
			 `TextEntry(`id(`name), "&Name:",    name ),
			 `TextEntry(`id(`addr), "&Address:", addr ),
			 `HBox(
			       `PushButton(`id(`ok     ), "&OK" ),
			       `PushButton(`id(`cancel ), "&Cancel" ),
			       `PushButton(`id(`help   ), "&Help"   )
			       )
			 )
		   );

    <b>symbol</b> widget_id = nil; // All widget IDs used here are symbols

    // Event loop

    repeat
    {
	widget_id = <em>UI::UserInput()</em>;

	if ( widget_id == `ok )
	{
	    // process "OK" button

	    y2debug( "OK button activated" );


	    // Retrieve widget contents

	    name = <b>UI::QueryWidget</b>(`id(`name ), `Value );
	    addr = <b>UI::QueryWidget</b>(`id(`addr ), `Value );
	}
	else if ( widget_id == `cancel )
	{
	    // process "Cancel" buttton
	    // or window manager close button (this also returns `cancel)

	    y2debug( "Cancel button activated" );
	}
	else if ( widget_id == `help )
	{
	    // process "Help" button

	    y2debug( "Help button activated" );
	}

	// No other "else" branch necessary: None of the TextEntry widget has
	// the `notify option set, so none of them can make UserInput() return.

    } until ( widget_id == `ok || widget_id == `cancel );



    // Close the dialog - but only after retrieving all information that may
    // still be stored only in its widgets: QueryWidget() works only for
    // widgets that are still on the screen!

    <b>UI::CloseDialog()</b>;


    // Dump the values entered into the log file

    y2debug( "Name: %1 Address: %2", name, addr );
}

</pre>




<h2><a name="PollInput">PollInput()</a></h2>

<p>
PollInput() is very much like <a href="#UserInput">UserInput()</a>, but it
doesn't wait. It only checks if there is a user event pending - the user may
have clicked on a button since the last call to PollInput() or
<a href="#UserInput">UserInput()</a>.
<p>
If there is one, the ID of the widget (usually a button unless other widgets
have the  <a href="events-general.html#notify">notify option</a> set) ID is
returned. If there is none, <i>nil</i> (the YCP value for "nothing", "invalid")
is returned.
<p>
Use PollInput() to check if the user wishes to abort operations of long
duration that are performed in a loop. Notice that PollInput() will result in a
"busy wait", so don't simply use it everywhere instead of
<a href="#UserInput">UserInput()</a>.
<p>
Notice there is also <a href="#TimeoutUserInput">TimeoutUserInput()</a>
and <a href="#WaitForEvent">WaitForEvent()</a>
that both accept a millisecond timeout argument.

<h3>Usage:</h3>
<pre class="code">
any widget_id = <b>UI::PollInput()</b>;

</pre>

<h3>Example:</h3>

<pre class="code">
// PollInput.ycp
//
// Example for common usage of UI::PollInput()

{
    // Build dialog with two labels and a "stop" button.

    integer count     = 0;
    integer count_max = 10000;

    <b>UI::OpenDialog</b>(
		   `VBox(
			 `Label( "Calculating..." ),
			 `Label(`id(`count ), sformat( "%1 of %2", count, count_max ) ),
			 `PushButton(`id(`stop), "&Stop" )
			 )
		   );

    any widget_id = nil;

    // Event loop

    repeat
    {
	widget_id = <em>UI::PollInput()</em>;


	// Simulate heavy calculation

	sleep(200); // milliseconds

	// Update screen to show that the program is really busy
	count = count + 1;
	<b>UI::ChangeWidget</b>(`id(`count), `Value, sformat( "%1 of %2", count, count_max ) );
	<b>UI::RecalcLayout()</b>; // Might be necessary when the label becomes wider

    } until ( widget_id == `stop || count >= count_max );

    <b>UI::CloseDialog()</b>;
}

</pre>



<h2><a name="TimeoutUserInput">TimeoutUserInput()</a></h2>

<p>
TimeoutUserInput() is very much like <a href="#UserInput">UserInput()</a>, but
it returns a predefined ID <i>`timeout</i> if no user input is available within
the specified (millisecond) timeout.
<p>
This is useful if there is a reasonable default action that should be done in
case of a timeout - for example, for popup messages that are not important
enough to completely halt a longer operation forever.

<p class="info-box">
<b>User interface style hint:</b> Use this with caution. It is perfectly OK to
use timeouts for informational messages that are not critical in any way
("<i>Settings are written</i>", "<i>Rebooting the newly installed kernel</i>"), but
definitely not if there are several alternatives the user can choose from. As a
general rule of thumb, if a dialog contains just an "OK" button and nothing
else, TimeoutUserInput() is appropriate. If there are more buttons, chances are
that the default action will cause disaster for some users.
<br>
Remember, timeouts are nearly always a desperate means. They are always both
too short and too long at the same time: Too short for users who know what
message will come and too long for users who left to get some coffee while the
machine is busy.
</p>


<p>
Another possible use of TimeoutUserInput() would be to periodically update the
screen with data that keep changing (time etc.) while waiting for user input.


<h3>Usage:</h3>
<pre class="code">
any widget_id = <b>UI::TimeoutUserInput( integer timeout_millisec )</b>;

</pre>

<h3>Example:</h3>

<pre class="code">
</pre>



<h2><a name="WaitForEvent">WaitForEvent()</a></h2>

<table class="navigation-bar" width=100%>
    <tr>
	<td width="33%" align="left">Prev: (none)</td>
	<td width="33%" align="center">Top: <a href="index.html">Event Handling Index</a></td>
	<td width="33%" align="right">Next: <a href="event-reference.html">Event Reference</a></td>
</table>

</body>
</html>


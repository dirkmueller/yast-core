Thoughts about YCP bytecode format


0. General
  - every object should get Save and Load functions
    to write itself to a stream and re-create itself
    by reading from the stream
  - the stream should be structured like the program
    (nested bytecode)
  - bytecode should be portable (endianess !)


1. Values
  Void
  - type
  Bool
  - type, char
  Int
  - type, 64bit in network byte order
  Float
  - type, IEEE compatible value
  String
  - type, 64bit len, set of chars
  Byteblock
  - type, len, set of bytes
  Path
  - type, component count, set of <count> string components
  Symbol
  - type, len, set of bytes
  Locale
  List
  Map

2. Types

  unneeded, type information is stripped

3. Expressions

  Propagate
  - unneeded
  Unary
  - op, expression
  Binary
  - expression, op, expression
  Triple
  - expression, expression, expression
  Compare
  - expression, op, expression
  Prefix
  - op, expression
  Locale
  - textdomain, string
  List
  - expression, expression, ...
  Map
  - (expression, expression), (expression, expression), ...
  Term
  - unneeded (either constant or function ref)
  Lookup
  - builtin
  Is
  - builtin
  Bracket
  - builtin
  Variable
  - block + offset
  Block
  - code

4. Statements

  Type
  - unneeded
  Variable Def
   init variable with default value
  Function Def
   - unneeded, part of scope, see block
  Assign
   - variabe, expression
  If
  While
  Do
  Repeat
  Expression
  Return
  Break
  Continue
  Undefine
  - unneeded
  Foreach
  Textdomain
  - unneeded
  Import
  - unneeded
  Bracket

5. Blocks

  Blocks are nested
  Blocks 'own' variables (SymbolEntry array)
  Variable references are based on block + array offset

  -> must save nesting level and re-construct SymbolEntry array on read

  This works for local entries only since they're 'saturated' (only intra-block
  references)

  For global variables (only useful inside modules !), a complete SymbolTable must
  be reconstructed since the block being read might be needed by the parser.
  -> keep global variables in SymbolTable

  The nesting level approach works ok for local blocks but fails for global
  ones (modules). Instead of the nesting level, a 'module index' should be
  used together with a list of imported modules.
  Maybe this can be replaced by an 'offset' in the block stack kept in Bytecode.
  The block-stack approach fails during import, since the entry references
  inside (!) the module are relative to the module (block id 0 refers to the
  modules block). So during module load (and variable de-referencing) a
  proper offset (block_id 0 refers to current stack id 42) could be sufficient.

6. Includes

7. Files
  The notion of a "compilation unit" might be useful.

--------------
TODO

- add module / namespace identifier to builtin declarations
- add type information to identifier (ensure that reference to a builtin function
    from a bytecode refers to the same function)
  i.e.  <module>:<builtin_function>:<type>

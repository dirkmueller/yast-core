<!-- $Id$ -->

<chapter id="language-description">
<title>YCP Language Description</title>

<!---------------------------------------------------------------------------->

<section id="motivation"><title>Motivation for YCP</title>
 <section><title>A bit of history</title>
 <para>
 </para>
 </section>
 <section><title>Why not Perl, Python, Tcl, ... ?</title>
 <para>
Because we defined the language requirements first and then looked at
a solution. The language has to be
<itemizedlist>
<listitem><para>small (it must be used during installation)</para></listitem>
<listitem><para>easy to learn and understand (this ruled out 'prolog' ;-))</para></listitem>
<listitem><para>fit to size (include only whats really needed)</para></listitem>
<listitem><para>easily extendable (need a new feature ? No problem !)</para></listitem>
<listitem><para>controllable by us (We must understand the source and fix bugs
  _immediately_ instead of asking some maintainers half around the world)</para></listitem>
<listitem><para>implemented as an interpreter (no edit-compile-link-test cycles)</para></listitem>
<listitem><para>usable as a prototype language (edit-test cycles !)</para></listitem>
<listitem><para>usable in a distributed/networked environment (-> ASCII !)</para></listitem>
<listitem><para>be politically clean (and there were enough 'political' pro and cons
  about _any_ existing language <computeroutput>:-)</computeroutput>)</para></listitem>
<listitem><para>coverable by the YaST license</para></listitem>
</itemizedlist>
The initial language design and implementation was done in about 2 weeks.
  </para>
  </section>
</section>

<!---------------------------------------------------------------------------->

<section id="types"><title>Types</title>

 <section><title>Basic types</title>

  <section><title>void</title>
  <para>
  <literal>void</literal> is the most simplest type with just a single value <literal>nil</literal>
  </para>
  <para>This basically means 'no specific value' and is used if functions don't explicit return a value.</para>
  <para>The <literal>void</literal> type is only allowed in function declarations, you cannot declare variables
  of type <literal>void</literal>.</para>
  <para></para>
  <para>Using <literal>void</literal> in expressions has a special meaning of <emphasis>exception</emphasis>
  and must be handled accordingly.</para><para>See <xref linkend="handling_nil"/> for further details.</para>
  <screen>
  nil
  </screen>
  </section>

  <section><title>boolean</title>
  <para>
  Boolean is just what you would expect with values <literal>true</literal> and <literal>false</literal>.
  </para>
  <screen>
  true
  false
  </screen>
  </section>

  <section><title>integer</title>
  <para>
  Integers are singed, 64bit values.
  </para>
  <screen>
  0
  -42
  1234567890
  </screen>
  </section>

  <section><title>float</title>
  <para>
  Float is implemented as a C++ <literal>double</literal> value.
  </para>
  <screen>
  0.0
  -42.42
  3.141592653
  </screen>
  </section>

  <section><title>string</title>
  <para>
  Strings are sequences of characters enclosed in double qoutes (<literal>"</literal>).
  </para>
  <para>Inside strings, the normal (C like) escape sequences are recognized (i.e. <literal>\n</literal> for line-feed)
  </para>
  <para>Non ASCII characters should be UTF-8 encoded.
  </para>
  <screen>
  ""
  "abc"
  "First line\nSecond line\n"
  </screen>
  </section>

  <section><title>byteblock</title>
  <para>
  Byteblock is used to specify a block of binary data.
  </para>
  <para>Syntactically, it starts with a hash mark (<literal>#</literal>) followed by an open square bracket
  (<literal>[</literal>), an even number of hexadecimal digits, and a closing square bracket
  (<literal>]</literal>).
  </para>
  <screen>
  #[000102030405060708090A0B0C0D0F]
  #[]
  #[DEADBEEF]
  </screen>
  </section>

  <section><title>symbol</title>
  <para>
  A symbol is a named constant
  </para>
  <screen>
  `foo
  `bar
  </screen>
  </section>

  <section><title>path</title>
  <para>
  A path is an ordered sequence of names
  </para>
  <screen>
  .
  .a.path.looks.like.this
  </screen>
  </section>

 </section>

 <section><title>Complex types</title>

  <section><title>list</title>
  <para>
  A list is an ordered set of values.
  </para>
  <screen>
  []
  [1,2,3,4,5]
  [true, "a", #[00]]
  </screen>
  </section>

  <section><title>map</title>
  <para>
  A map is a set of key/value pairs.
  </para>
  <screen>
  $[]
  $[0 : "zero", 1 : "one", 2 : "two" ]
  $["zero" : 0, "one" : 1, "two" :2 ]
  </screen>
  </section>

  <section><title>term</title>
  <para>
  A term is an unevaluated function call.
  </para>
  <screen>
  `name (arg1, arg2, arg3)
  </screen>
  </section>

 </section>

 <section><title>Modifiers</title>

  <section><title>const</title>
  <para>
  Declares a variable as 'read-only' so it can't be modified by assignment.
  </para>
  <para>
  not implemented yet
  </para>
  <screen>
  const integer the_answer = 42;	// clearly unchangable value ;-)
  </screen>
  <para>A constant map or a map of constants
  <screen>
  const map integer m1 = [ 1, 2, 3, 4 ];
  map const integer m2 = [ 5, 6, 7, 8 ];
  </screen>
  <literal>const</literal>, being a prefix modifier, binds the closest type
  to its right. So <literal>m1</literal>, being a constant map, can't be changed.
  <literal>m2</literal> is a map of constant integers, so map elements can be
  added or deleted, but their value can't be changed.</para>
  </section>

 </section>

 <section><title>References</title>
 <para>
 Useful for explicit 'call by reference' of function arguments.
 </para>
 <para>
  not implemented yet
 </para>
 <screen>
 void increment (integer & i) { i = i + 1; }
 </screen>
 <para>
 You can't mix <literal>const</literal> and <literal>&</literal>.</para>
 <para>References are not pointers but for implementing 'call by reference'
 because a variables value should be changed from inside the function.</para>
 <para>Since a <literal>const</literal> value can't be changed, const value references
 are not needed.</para>
 </section>

 <section><title>Tuples</title>
 <para>
 Useful for returning several arguments from a function. Esp. in combination with <literal>Perl::</literal>
 </para>
 <para>
  not implemented yet
 </para>
 <screen>
 (integer, integer) division (integer dividend, integer divisor) { // integer division returning quotient and reminder }
 </screen>
 <para>
 To be evaluated ...
 </para>
 </section>

</section>

<!---------------------------------------------------------------------------->

<section id="expressions"><title>Expressions</title>
<section id="operators"><title>Operators</title>
 <section><title>Prefix</title>
 <para>
!, ~
 </para>
 </section>
 <section><title>Infix</title>
 <para>
+, -, *, /
 </para>
 </section>
 <section><title>Locales</title>
 <para>
_("..."), _("...", "...", int)
 </para>
 </section>
 <section><title>Bracket</title>
 <para>
 </para>
 </section>
</section>
<section id="handling_nil"><title>Handling <literal>nil</literal></title>
 <para>
 Using <literal>nil</literal> in expressions needs to be done with special care since
 <literal>nil</literal> is no ordinary value which can be processed further.
 </para>
 <para>If a function might return <literal>nil</literal>, the caller must be prepared
 to handle this return value. This is done by checking for (in)equality with <literal>nil</literal>.
 </para>
 <para>There are some builtin functions which know how to cope with <literal>nil</literal>,
 but this is an exception. Usually, a <literal>nil</literal> value in an expression yields
 the complete expression to <literal>nil</literal>.
 </para>
</section>
</section>


<!---------------------------------------------------------------------------->

<section id="statements"><title>Statements</title>
 <para>
 Statements can only appear inside a block and do not have a value.
 </para>
 <section><title>if-then-else</title>
 <para>
 </para>
 </section>
 <section><title>while</title>
 <para>
 </para>
 </section>
 <section><title>block</title>
 <para>
 A block is an ordered sequence of statements.
 </para>
 <para>
 Blocks are enclosed in curly braces (<literal>{</literal> and <literal>}</literal>).
 </para>
 <para>
 Blocks can also be evaluated and therefore have a value. The default value of
 a block is of type <literal>void</literal>. Other values can be specified with
 the <literal>return</literal> statement.
 </para>
 </section>
 <section><title>return</title>
 <para>
 The <literal>return</literal> statement defines the value of the innermost block.
 </para>
 </section>
 <section><title>textdomain</title>
 <para>
 The <literal>textdomain</literal> statement is used in conjunction with locales.
 It defines the translation domain for the locale string. Before using a locale expression,
 a textdomain must be defined with the <literal>textdomain</literal> statement.
 </para>
 </section>
</section>


<!---------------------------------------------------------------------------->

<section id="builtins"><title>Builtins</title>
 <section><title>bool</title>
 <para>
 </para>
 </section>
 <section><title>integer</title>
 <para>
 </para>
 </section>
 <section><title>string</title>
 <para>
 </para>
 </section>
 <section><title>list</title>
 <para>
 </para>
 </section>
 <section><title>map</title>
 <para>
 </para>
 </section>
</section>


<!---------------------------------------------------------------------------->

<section id="functions"><title>Functions</title>
 <section><title>usage</title>
 <para>
 </para>
 </section>
 <section><title>define</title>
 <para>
 </para>
 </section>
 <section><title>global (scope)</title>
 <para>
 </para>
 </section>
</section>


<!---------------------------------------------------------------------------->

<section id="modules"><title>Modules</title>
 <section><title>usage</title>
 <para>
 </para>
 </section>
 <section><title>constructors</title>
 <para>
 </para>
 </section>
 <section><title>scope</title>
 <para>
 </para>
 </section>
</section>


<!---------------------------------------------------------------------------->

<section id="externals"><title>Externals</title>
 <section><title>UI</title>
 <para>
 </para>
 </section>
 <section><title>SCR</title>
 <para>
 </para>
 </section>
 <section><title>WFM</title>
 <para>
 </para>
 </section>
</section>

</chapter>

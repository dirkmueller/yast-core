$Id$

A static type system for YCP

The currently implemented dynamic type system was
choosen to support operator/function overloading.

However, this approach has some drawbacks

- no parse-time checking of use of undeclared variables.
- each and every function must check the types of it's
  parameters at runtime (major performance and code size
  drawback).
- no central (!) type checking


A static type system introduces parse-time type and
variable usage checking. So undeclared variables or
wrong types are detected before actually running the
code.

==> This requires (pre-) declarations of all variables and
functions.

Q: How to do predeclarations ?
A1: In include files. This is ok for ycp functions but not for builtins.
A2: In static structs inside C++ code. This is the only way for builtins.

The static declarations cannot use YCPValue for the type descriptions
since YCPValue cannot be declared statically. It's a pure runtime value.
So we need something besides YCPValue for the type descriptions.

Possible solutions
S1: Run some init() function to initialize YCPValue for predeclarations.
    To minimize code, this needs some coded description.
S2: Use a different encoding for types, not YCPDeclType.

Q: Why do we use YCPDeclType (a YCPValue) for declarations in the first place ?
A: For simple handling inside the interpreter and to make type expressions
   possible. Especially the latter isn't used any more, so we can drop it.

Solution.

Use a new encoding for types. For compatibility reasons, this may still
be wrapped-up in YCPDeclType().
This will make type checking quicker and less memory consuming since
it's not coded in YCPValue any more. But: Declarations are no values now !!

The new type encoding is based on strings. It allows to encode simple
types (i.e. integer, boolean, string, ...) and complex types (i.e.
functions with parameters). Additionally, type modifiers (i.e. unsigned,
reference, ...) can be encoded.

Base types are encoded with a lower case letter:

(see YBuiltin.h for the complete list)

any		a
any		A	(return type, see below)

void		v	where is this used ?
			nil is a value of type any
			but we must distinguish between the unspecified type (returned by a function)
			and the 'joker/wildcard' type denoted by 'nil'
			-> 'v' is needed and defines the 'wildcard' type

boolean		b
integer		i
float		f
string		s
byteblock	o	(for 'o'ctet :-))
path		p
symbol		y
declaration	d	(still needed ?) No, not needed !
locale		_
list		La	(list of element with any type)
list()		Lx	(list of elements with equal type x)
term		t
map		Ma	(map of keys with any type)
map()		Mx	(map of keys with equal type x)
block		Cx	(for 'C'ode returning x)

(builtin, identifier, and error from YCPValue.h don't need an encoding
since they're only used internally).

Simple types just need a single character for type encoding as listed
above.
Lists can be specified with ('Lx', x = type) or without ('La') type
restriction for its elements. Having a list of terms ('Lt') makes it
possible to specify function (or symbol) lists

 list funlist = [ ``(foo()), ``(bar())];
 list symlist = [ `foo, `bar ];

without the need for double-qoutes

 list (term) funlist = [ foo(), bar() ];
 list (symbol) symlist = [ foo, bar ];


Functions with arguments and a return type need a bit more:

- the return type
- a vertical bar '|'
- the type of each argument

UNUSED:
The encoding is done by using digits to encode the parameter count. So if
a type is followed by a digit, it denotes a return type of a function
and the digit is the number of arguments.

b|		boolean ()	function with no arguments, returning boolean
l|bms		list (boolean, map, string)

Remark: It's a pure type encoding, not a name mangling as in C++ which includes
the variable names.

With this encoding, static predeclarations can be coded in C++:

(see StaticDeclaration.h for the exact definition of the array
 initialization quoted below !)

// name, type, builtin code, pointer to function
{ "splitstring", "l|ss", s_splitstring, 0 }

// list splitstring (string target, string separator)


Some functions like lookup and select have a variable return type, depending
on the map or list they get as an argument. But since the return type has
to be fix, there is the special argument type 'A'. It means that the return
type is the same as the type of the argument. E.g.:

{ "lookup", "A|maA", m_lookup, 0 }

Thus the return value has the same type as the default value.
Exception: If the default value is 'nil' (typecode 'v'), it converts to any (typecode 'a')
Example: lookup ($[1:1], 1, nil) -> any (not 'void' !!)

Function overloading is done by multiple entries:

// list add (list targetlist, any value)
{ "add", "l|la", l_add, 0 },
// map add (map targetmap, any key, any value)
{ "add", "Ma|Maaa", m_add, 0 }


Variable number of arguments.

Functions like "y2milestone" expect a variable number of arguments (printf
style). This can be encoded by using 'w' (wildcard).

The encoding for 'void y2milestone (string format, ...)' is
"v|sw".


Type checking can now be done _once_, _before_ calling the function.
Constructed terms (by 'add'ing parameters to a term in YCP) still need
 runtime checking. All other terms can be checked statically.
-> evaluation of a term needs checking.


Encoding of type modifiers.

Type modifiers (like unsigned, reference ...) are encoded by using uppercase
letters. "Ri" encodes "integer &", "Ui" encodes "unsigned integer",
"Cs" encodes "const string".

reference	R
unsigned	U	UNUSED
const		C	NO, C means block

20-08-2001 kkaempf@suse.de

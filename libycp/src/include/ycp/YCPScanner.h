/*---------------------------------------------------------------------\
|                                                                      |  
|                      __   __    ____ _____ ____                      |  
|                      \ \ / /_ _/ ___|_   _|___ \                     |  
|                       \ V / _` \___ \ | |   __) |                    |  
|                        | | (_| |___) || |  / __/                     |  
|                        |_|\__,_|____/ |_| |_____|                    |  
|                                                                      |  
|                               core system                            | 
|                                                        (C) SuSE GmbH |  
\----------------------------------------------------------------------/ 

   File:       YCPScanner.h

   Author:     Mathias Kettner <kettner@suse.de>
   Maintainer: Thomas Roelz <tom@suse.de>

/-*/
// -*- c++ -*-

/*
 * YCP interface to the flex generated scanner
 *
 * Author: Mathias Kettner <kettner@suse.de>
 */

#ifndef YCPScanner_h
#define YCPScanner_h

#include "FlexLexer.h"
#include <stdio.h>
#include <string>
#include "YCP.h"

/**
 * @short Scanner for parsing YCP syntax
 * @see YCPParser
 * This class is a filter. You give it a YCP text in form of
 * a string, a FILE *pointer or a unix file descriptor. Out of this
 * it produces a stream of tokens representing the lexical items
 * of the YCP text. This scanner class is based on yyFlexLexer, 
 * which is generated by flex++.
 */
class YCPScanner : public yyFlexLexer
{
    /**
     * Allocate this many bytes for a string. If a larger
     * string is encountered, the buffer size is at least doubled.
     * I don't believe, that the value of STRING_HUNK has a great
     * impact on speed. 1024 is probably a nice value for it.
     */
    static const int STRING_HUNK = 1024;

    /**
     * The name of the file being parsed. It is used for generating
     * nice error messages only. It is the empty string, if no filename
     * is available (e.g. while scanning from stdin).
     */
    string filename;

    /**
     * If the YCP text source is given in form of a string buffer,
     * this buffer is stored here. 0 otherwise.
     */
    const char *inputbuffer;

    /**
     * If the YCP text source is given in form of an open clib-level
     * file pointer, this variable hold it. Must be 0 otherwise.
     */
    FILE *inputfile;

    /**
     * If the YCP text source is given in form of a unix lowlevel file
     * descriptor, this variable holds the descriptor. Must be -1 otherwise,
     * since 0 is a valid file descriptor (stdin).
     */
    int input_fd;

    /**
     * Holds the value being scanned lastly.
     */
    YCPValue scanned_value;

    /**
     * Holds the line number of scanned_value
     */
    int line_number;

    /**
     * Used for string constant scanning
     */
    char *scandata_buffer_ptr;

    /**
     * Used for string constant scanning
     */
    char *scandata_buffer;

    /**
     * Used for string constant scanning
     */
    int scandata_buffer_size;

    /**
     * Is true, if the input can be buffered, i.e. more than one
     * character may be read at once in order to gain performance.
     */
    bool buffered;

public:
    /**
     * Creates a new scanner that scans from an open clib-level
     * file descriptor that has been opened with fopen(filename, "r").
     * You have to close the file yourself afterwards.
     * @param inputfile the open file
     * @param filename If you have the name of the file in hand here,
     * tell it, it makes nicer error messages. Give 0 otherwise.
     */
    YCPScanner(FILE *inputfile, const char *filename);

    /**
     * Creates a new scanner that scans from a zero terminated constant C string.
     * Your buffer is left untouched. We don't make a copy of it, so ist must
     * be valid all the time this class is used.
     * @param inputbuffer Pointer to the string.
     */
    YCPScanner(const char *inputbuffer);

    /**
     * Creates a new scanner that scans from an open unix
     * lowlevel file descriptor. You have to close the descriptor 
     * yourself afterwards
     * @param input_fd the file descriptor
     * @param filename If you have the name of the file in hand here,
     * tell it, it makes nicer error messages. Give 0 otherwise.
     */
    YCPScanner(int input_fd, const char *filename);

    /**
     * Cleans up
     */
    ~YCPScanner();

    /**
     * Makes the scanner use buffering, i.e. read more than
     * one character at once.
     */
    void setBuffered();

    /**
     * Scans and returns the next token. Return 0, in case of EOF.
     * The value of the scanned token is saved in @ref #scanned_value and
     * can be retrieved with @ref #getScannedValue. The implementation of
     * this function is generated by flex++.
     */
    int yylex();

    /**
     * Overriden from @ref yyFlexLexer. The flex scanner uses this
     * function to get the next input characters. Our implementation
     * always returns just one character. Too much lookahead would result
     * in blocking and deadlock in a protocol situation.
     * FIXME: when reading from file read max_size characters
     * @param buf Buffer where the input is to be stored in
     * @param max_size size of this buffer
     * @return the number of new input character. 0 on EOF.
     */
    int LexerInput( char* buf, int max_size );

    /**
     * Is called by the flex lexer, if a scan error occurs.
     * Calls @ref #logError.
     */
    void LexerError( const char* msg );

    /**
     * Gets the value of the latest scanned token. Returns
     * 0, if that token does not represent a YCP value. You
     * get a clone of the value, so be sure, that you destroy
     * it after use or feed it into an YCP constructor.
     * A subsequent call to getScannedValue() will yield 0.
     */
    YCPValue getScannedValue();

    /**
     * Gets the line number of the latest scanned token.
     */
    int getLineNumber();

    /**
     * Is called by @ref #LexerError.
     * Is also called by yyerror for error reporting. It reports
     * the error via y2log and also reports the filename, if available
     * and the linenumber.
     * @param msg the plain error message
     */
    void logError(const char *loginfo, int lineno, ...) __attribute__ ((format (printf, 2, 4)));
    
private:
    /**
     * Used in the rules of the scanner to define the value
     * of a token. This class takes over the memory management.
     * So it is legal to write for example setScannedValue(new YCPVoidRep());
     */
    void setScannedValue(const YCPValue& v, int lineno = 0);

    /**
     * Internal helper function that deals with strings of arbitrary
     * length
     */
    char *extend_scanbuffer(int size);

};

#endif // YCPScanner_h
